"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$fill = void 0;
var core_1 = require("../../core");
var util_1 = require("../../util");
var ifNull_1 = require("../expression/conditional/ifNull");
var addFields_1 = require("./addFields");
var setWindowFields_1 = require("./setWindowFields");
var FILL_METHODS = {
    locf: "$locf",
    linear: "$linearFill",
};
// ensure $ifNull expression is loaded.
(0, core_1.useOperators)(core_1.OperatorType.EXPRESSION, { $ifNull: ifNull_1.$ifNull });
/**
 * Populates null and missing field values within documents.
 *
 * @param {Iterator} collection
 * @param {Object} expr
 * @param {Options} options
 */
function $fill(collection, expr, options) {
    var _a;
    var _b, _c;
    (0, util_1.assert)(!expr.sortBy || (0, util_1.isObject)(expr.sortBy), "sortBy must be an object.");
    (0, util_1.assert)(!!expr.sortBy || Object.values(expr.output).every(function (m) { return (0, util_1.has)(m, "value"); }), "sortBy required if any output field specifies a 'method'.");
    (0, util_1.assert)(!(expr.partitionBy && expr.partitionByFields), "specify either partitionBy or partitionByFields.");
    (0, util_1.assert)(!expr.partitionByFields ||
        ((_b = expr === null || expr === void 0 ? void 0 : expr.partitionByFields) === null || _b === void 0 ? void 0 : _b.every(function (s) { return s[0] !== "$"; })), "fields in partitionByFields cannot begin with '$'.");
    var partitionExpr = expr.partitionBy || ((_c = expr === null || expr === void 0 ? void 0 : expr.partitionByFields) === null || _c === void 0 ? void 0 : _c.map(function (s) { return "$".concat(s); }));
    // collect and remove all output fields using 'value' instead of 'method'.
    // if there are any fields remaining, process collection using $setWindowFields.
    // if the collected output fields is non-empty, use $addFields to add them to their respective partitions.
    var valueExpr = {};
    var methodExpr = {};
    for (var _i = 0, _d = Object.entries(expr.output); _i < _d.length; _i++) {
        var _e = _d[_i], k = _e[0], m = _e[1];
        if ((0, util_1.has)(m, "value")) {
            // translate to expression for $addFields
            valueExpr[k] = { $ifNull: ["$$CURRENT.".concat(k), m["value"]] };
        }
        else {
            // translate to output expression for $setWindowFields.
            var fillOp = FILL_METHODS[m["method"]];
            (0, util_1.assert)(!!fillOp, "invalid fill method '".concat(m["method"], "'."));
            methodExpr[k] = (_a = {}, _a[fillOp] = "$" + k, _a);
        }
    }
    // perform filling with $setWindowFields
    if (Object.keys(methodExpr).length > 0) {
        collection = (0, setWindowFields_1.$setWindowFields)(collection, {
            sortBy: expr.sortBy,
            partitionBy: partitionExpr,
            output: methodExpr,
        }, options);
    }
    // fill with values
    if (Object.keys(valueExpr).length > 0) {
        collection = (0, addFields_1.$addFields)(collection, valueExpr, options);
    }
    return collection;
}
exports.$fill = $fill;
